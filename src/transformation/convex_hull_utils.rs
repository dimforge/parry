use alloc::vec::Vec;

#[cfg(feature = "dim3")]
use crate::bounding_volume;
#[cfg(feature = "dim3")]
use crate::math::DIM;
use crate::math::{Point, Real};
use crate::num::Bounded;
use na;

#[derive(thiserror::Error, Debug, PartialEq)]
/// Errors generated by the convex-hull calculation.
pub enum ConvexHullError {
    /// Reached an impossible configuration in the convex-hull calculation,
    /// likely because of a bug.
    #[error("Internal error: {0}")]
    InternalError(&'static str),
    /// The convex hull calculation was unable to find a support point.
    /// This generally happens if the input point set contains invalid points (with NaN coordinates)
    /// or if they are almost coplanar.
    #[error("Input points are either invalid (NaN) or are almost coplanar.")]
    MissingSupportPoint,
    /// The convex-hull calculation failed because less than 2 points were provided.
    #[cfg(feature = "dim2")]
    #[error("Less than 2 points were given to the convex-hull algorithm.")]
    IncompleteInput,
    /// The convex-hull calculation failed because less than 3 points were provided.
    #[cfg(feature = "dim3")]
    #[error("Less than 3 points were given to the convex-hull algorithm.")]
    IncompleteInput,
    /// Reached a piece of code we shouldnâ€™t (internal error).
    #[error("Internal error: unreachable code path")]
    Unreachable,
}

impl ConvexHullError {
    #[cfg(feature = "dim2")]
    pub(crate) fn incorrect_empty() -> Vec<Point<Real>> {
        Vec::new()
    }

    #[cfg(feature = "dim3")]
    pub(crate) fn incorrect_empty() -> (Vec<Point<Real>>, Vec<[u32; DIM]>) {
        (Vec::new(), Vec::new())
    }
    #[cfg(feature = "dim2")]
    pub(crate) fn into_incorrect_empty(self) -> Vec<Point<Real>> {
        Self::incorrect_empty()
    }

    #[cfg(feature = "dim3")]
    pub(crate) fn into_incorrect_empty(self) -> (Vec<Point<Real>>, Vec<[u32; DIM]>) {
        Self::incorrect_empty()
    }
}

/// Returns the index of the support point of a list of points.
pub fn support_point_id<const D: usize>(
    direction: &na::SVector<Real, D>,
    points: &[na::Point<Real, D>],
) -> Option<usize> {
    let mut argmax = None;
    let _max: Real = Bounded::max_value();
    let mut max = -_max;

    for (id, pt) in points.iter().enumerate() {
        let dot = direction.dot(&pt.coords);

        if dot > max {
            argmax = Some(id);
            max = dot;
        }
    }

    argmax
}

/// Returns the index of the support point of an indexed list of points.
pub fn indexed_support_point_id<I, const D: usize>(
    direction: &na::SVector<Real, D>,
    points: &[na::Point<Real, D>],
    idx: I,
) -> Option<usize>
where
    I: Iterator<Item = usize>,
{
    let mut argmax = None;
    let mut max = -Real::MAX;

    for i in idx.into_iter() {
        let dot = direction.dot(&points[i].coords);

        if dot > max {
            argmax = Some(i);
            max = dot;
        }
    }

    argmax
}

/// Returns the number `n` such that `points[idx.nth(n)]` is the support point.
#[cfg(feature = "dim3")] // We only use this in 3D right now.
pub fn indexed_support_point_nth<I, const D: usize>(
    direction: &na::SVector<Real, D>,
    points: &[na::Point<Real, D>],
    idx: I,
) -> Option<usize>
where
    I: Iterator<Item = usize>,
{
    let mut argmax = None;
    let mut max = -Real::MAX;

    for (k, i) in idx.into_iter().enumerate() {
        let dot = direction.dot(&points[i].coords);

        if dot > max {
            argmax = Some(k);
            max = dot;
        }
    }

    argmax
}

/// Scale and center the given set of point depending on their Aabb.
#[cfg(feature = "dim3")]
pub fn normalize(coords: &mut [Point<Real>]) -> (Point<Real>, Real) {
    let aabb = bounding_volume::details::local_point_cloud_aabb(&*coords);
    let diag = na::distance(&aabb.mins, &aabb.maxs);
    let center = aabb.center();

    for c in coords.iter_mut() {
        *c = (*c + (-center.coords)) / diag;
    }

    (center, diag)
}
